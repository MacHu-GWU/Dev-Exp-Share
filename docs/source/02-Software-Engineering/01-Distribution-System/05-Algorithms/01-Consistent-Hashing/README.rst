.. _consistent-hash-algorithm:

Consistent Hash 一致性哈希算法
==============================================================================
Keywords: Consistent Hash, Load Balancer, Scale

.. contents::
    :class: this-will-duplicate-information-and-it-is-still-useful-here
    :depth: 1
    :local:


背景
------------------------------------------------------------------------------
负载均衡算法的功能主要是 "将流量均匀地或是按照算力加权依概率分配到 N 个负载上". 而在实现上通常是对流量进行 hash, 然后使用负载均衡算法函数将 hash 结果映射到 N 个负载的序号上.

举例来说, 我们用 MD5 作为我们的 hash 函数, 计算得到一个整数, 然后对 N 取余数, 余数的结果就是负载的序号.

这个算法有一个致命的问题, 当需要增加或减少节点的时候, 由于除数 N 改变了, 所有的余数也会改变, 所以就不可避免的需要将数据从原来的负载迁徙到新的负载上. 如下图所示. 如果你目前已经有 K 个节点, 每增加一台机器, 你就需要迁徙 ``K / (K+1)`` 比例的数据. 一般的分布式系统为了保证稳定性起码要有 3 个节点, 那么每次增加节点就要迁徙至少 75% 的数据, 随着 K 的增加这个迁徙量会越来越多. 在数据迁徙期间, 负载节点如果继续提供服务, 则数据可能会出错. 所以常见的做法是在迁徙期间只允许读, 不允许写. 由于迁徙量很大, 这使得服务不可用的时间较长, 显然这是不可接受的.

.. raw:: html
    :file: ./consistent-hashing-1.html

于是, `1997 年 麻省理工大学提出了该算法, 用于解决这一问题 <https://en.wikipedia.org/wiki/Consistent_hashing#:~:text=In%20computer%20science%2C%20consistent%20hashing,is%20the%20number%20of%20slots.>`_

一致性哈希算法在分布式系统中应用广泛, 凡是可以通过添加机器扩容的系统大部分采用了 ``一致性哈希算法`` 进行负载均衡. 解决了增加和减少机器时, 由于数据迁徙带来的服务不可用的时间过长的问题.


一致性哈希算法
------------------------------------------------------------------------------


取一个 0 ~ 2 ^ 32 - 1 的整数环 M, 环上的数 12 点钟方向为 0, 数字沿着顺时针递增. 对 hash(id) 求 mod(2 ^ 32) = x. 将 M 平均划分为 N 段, N 为分布式节点数. 第 i 段的终点为 i * 2 ^ 32 / N. 对于负载 x 沿着顺时针方向寻找最近的一个终点, 该终点是第 i 段, 那么负载就放到第 i 个机器上进行.

**常见问题**:

- Q: 传统哈希算法有什么问题?
- A: 假设我们有 3 个节点 (N = 3), 映射规律为 3k + 0 -> n1, 3k + 1 -> n2, 3k + 2 -> n3, (3k+0,1,2, 为 hash(id)的结果). 如果我们增加一个节点, 新的映射规律为 4k + 0 -> n1, 4k + 1 -> n2, 4k + 2 -> n3, 4k + 3 -> n4, 那么根据概率, 有 75% (3/4) 的负载需要移动到新的节点上处理. 数学上我们可以证明, 从 N 扩容到 N+1, 需要有 N/(N+1) 的负载需要改变新的节点.

- Q: 一致性哈希算法在扩容的场景下, 需要做什么?
- A: 在一致性哈希算法中, 我们扩容的时候仅仅是将第 N 段一分为二从中间断开, 并增加一个新的终点作为新节点的终点. 那么只有 1 / 2N 的负载需要改变新的节点, 当 N = 3 时是 16.6%, 比之前的 75% 有巨大改善.

- Q: 在上面的描述中, 只有那个被一分为二的段所对应的节点的负载被分流了, 另外的节点的负载并没有降低, 如何解决?
- A: 引入虚拟节点, 可以视为是一致性哈希算法的改进版本, 一开始, 我们将环 M 平均划分为 N ^ 2 段, 在该例子中为 9 段, 连续的 9 段对应的环是依次变换的, 分别对应节点 N1, N2, N3, N1, N2, N3, N1, N2, N3. 在添加新的节点时, 找到 3 个不同节点所属的段对其一分为二. 这样能保证新加的节点从原本的 N 个小段中分别获得了一部分负载, 使得总体上的 N + 1 台机器负责的负载依然是相同的.
