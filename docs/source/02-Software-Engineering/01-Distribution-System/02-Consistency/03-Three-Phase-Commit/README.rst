.. _three-phase-commit:

Three Phase Commit 又叫 3PC, 两阶段提交
==============================================================================
Keywords: distributive system, consistency protocol

Ref:

- https://zhuanlan.zhihu.com/p/35616810
- https://cloud.tencent.com/developer/article/1100494

.. contents::
    :class: this-will-duplicate-information-and-it-is-still-useful-here
    :depth: 1
    :local:


Summary
------------------------------------------------------------------------------
三阶段提交 (Three phase commit), 也叫三阶段提交协议 (Three phase commit protocol), 是二阶段提交(2PC) 的改进版本. 建议先理解了 :ref:`two-phase-commit` 之后再阅读本文.

与两阶段提交不同的是，三阶段提交有两个改动点。

1. 引入超时机制. 同时在协调者和参与者中都引入超时机制.
2. 在第一阶段和第二阶段中插入一个准备阶段, 保证了在最后提交阶段之前各参与节点状态的一致.

也就是说, 除了引入超时机制之外, 3PC 把 2PC 的投票阶段再次一分为二, 这样三阶段提交就有 CanCommit, PreCommit, DoCommit 三个阶段.

为什么要把投票阶段一分为二?

假设有 1 个协调者, 9 个参与者. 其中有一个参与者不具备执行该事务的能力.

协调者发出 prepare 消息之后, 其余参与者都将资源锁住, 执行事务, 写入 undo 和 redo 日志.

协调者收到相应之后, 发现有一个参与者不能参与. 所以, 又出一个 rollback 消息. 其余8个参与者, 又对消息进行回滚. 这样子, 是不是做了很多无用功?

所以，引入 can-commit 阶段, 主要是为了在预执行之前, 保证所有参与者都具备可执行条件, 从而减少资源浪费.


CanCommit 阶段
------------------------------------------------------------------------------
3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像. 协调者向参与者发送 commit 请求, 参与者如果可以提交就返回 Yes 响应, 否则返回 No 响应.

1. 事务询问: 协调者向参与者发送 CanCommit 请求. 询问是否可以执行事务提交操作. 然后开始等待参与者的响应.
2. 响应反馈: 参与者接到 CanCommit 请求之后, 正常情况下, 如果其自身认为可以顺利执行事务, 则返回 Yes 响应, 并进入预备状态. 否则反馈 No.

PreCommit 阶段
------------------------------------------------------------------------------
本阶段协调者会根据第一阶段的询盘结果采取相应操作, 询盘结果主要有两种:

情况1, 假如协调者从所有的参与者获得的反馈都是 Yes 响应, 那么就会执行事务的预执行:

1. 发送预提交请求: 协调者向参与者发送 PreCommit 请求, 并进入 Prepared 阶段.
2. 事务预提交: 参与者接收到 PreCommit 请求后, 会执行事务操作, 并将 undo 和 redo 信息记录到事务日志中.
3. 响应反馈: 如果参与者成功的执行了事务操作, 则返回 ACK 响应, 同时开始等待最终指令.

情况2, 假如有任何一个参与者向协调者发送了 No 响应, 或者等待超时之后, 协调者都没有接到参与者的响应, 那么就执行事务的中断. 具体步骤如下:

1. 发送中断请求: 协调者向所有参与者发送 abort 请求.
2. 中断事务: 参与者收到来自协调者的 abort 请求之后 (或超时之后, 仍未收到协调者的请求), 执行事务的中断.


DoCommit 阶段
------------------------------------------------------------------------------
该阶段进行真正的事务提交, 也可以分为以下两种情况.

情况1, 执行提交:

针对第一种情况, 协调者向各个参与者发起事务提交请求, 具体步骤如下:

1. 协调者向所有参与者发送事务 commit 通知
2. 所有参与者在收到通知之后执行 commit 操作, 并释放占有的资源
3. 参与者向协调者反馈事务提交结果

情况2, 中断事务:

协调者没有接收到参与者发送的 ACK 响应 (可能是接受者发送的不是 ACK 响应, 也可能响应超时), 那么就会执行中断事务. 具体步骤如下:

1. 发送中断请求: 协调者向所有参与者发送事务 rollback 通知.
2. 事务回滚: 所有参与者在收到通知之后执行 rollback 操作, 并释放占有的资源.
3. 反馈结果: 参与者向协调者反馈事务提交结果.
4. 中断事务: 协调者接收到参与者反馈的 ACK 消息之后, 执行事务的中断.


总结
------------------------------------------------------------------------------
相对于2PC, 3PC主要解决的单点故障问题, 并减少阻塞, 因为一旦参与者无法及时收到来自协调者的信息之后, 他会默认执行 commit. 而不会一直持有事务资源并处于阻塞状态.

在 doCommit 阶段, 如果参与者无法及时接收到来自协调者的 doCommit 或者 abort 请求时, 会在等待超时之后, 会继续进行事务的提交.

其实这个应该是基于概率来决定的, 当进入第三阶段时, 说明参与者在第二阶段已经收到了 PreCommit 请求, 那么 Coordinator 产生 PreCommit 请求的前提条件是他在第二阶段开始之前, 收到所有参与者的 CanCommit 响应都是 Yes. 一旦参与者收到了 PreCommit, 意味他知道大家其实都同意修改了.

所以, 一句话概括就是, 当进入第三阶段时, 由于网络超时等原因, 虽然参与者没有收到 commit 或者 abort 响应, 但是他有理由相信: 成功提交的几率很大.

但是这种机制也会导致数据一致性问题, 因为, 由于网络原因, 协调者发送的 abort 响应没有及时被参与者接收到, 那么参与者在等待超时之后执行了 commit 操作. 这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况.

如果进入 PreCommit 后, 协调者发出的是 abort 请求, 如果只有一个参与者收到并进行了 abort 操作, 而其他对于系统状态未知的参与者会根据 3PC 选择继续 Commit, 那么系统的不一致性就存在了. 所以无论是 2PC 还是 3PC 都存在问题, 只是 3PC 的出错概率更低, 后面会继续了解传说中唯一的一致性算法 Paxos.
