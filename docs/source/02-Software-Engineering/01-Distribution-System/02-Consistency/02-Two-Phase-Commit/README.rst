.. _two-phase-commit:

Two Phase Commit 又叫 2PC, 两阶段提交
==============================================================================

Keywords: distributive system, consistency protocol

Ref:

- https://zhuanlan.zhihu.com/p/35616810
- https://cloud.tencent.com/developer/article/1100494

.. contents::
    :class: this-will-duplicate-information-and-it-is-still-useful-here
    :depth: 1
    :local:


Summary
------------------------------------------------------------------------------
2PC 是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法 (Algorithm)。通常，二阶段提交也被称为是一种协议 (Protocol)。

在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。

当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点 (称作参与者) 的操作结果并最终指示这些节点是否要把操作结果进行真正的提交 (比如将更新后的数据写入磁盘等等)。

因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。

所谓的两个阶段是指：

1: voting phase 投票阶段
2. commit phase 提交阶段


Voting Phase 投票阶段
------------------------------------------------------------------------------
事务协调者给每个参与者发送 Prepare 消息，每个参与者要么直接返回失败 (如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种 "万事俱备，只欠东风" 的状态。

投票阶段有 3 个步骤:

1. 协调者节点向所有参与者节点询问是否可以执行提交操作, 并开始等待各参与者节点的响应. 这个询问的动作叫做 Vote. 该步骤只是检查通信和权限, 并不真正写 redo 和 undo 日志.

2. 参与者节点检查事务权限, 执行询问发起为止的所有事务操作, 并将 redo 信息和 undo 信息写入日志. (注: 为什么在执行任务前需要先写本地日志, 主要是为了故障后恢复用, 本地日志起到现实生活中 凭证 的效果, 如果没有本地日志 凭证, 出问题容易死无对证.)

3. 各参与者节点响应协调者节点发起的询问. 如果参与者节点的事务操作实际执行成功, 则它返回一个 "同意" 消息; 如果参与者节点的事务操作实际执行失败, 则它返回一个 "中止" 消息.


Commit Phase 提交阶段
------------------------------------------------------------------------------
如果协调者收到了参与者的失败消息或者超时, 直接给每个参与者发送回滚 (Rollback) 消息; 否则, 发送提交(Commit) 消息; 参与者根据协调者的指令执行提交或者回滚操作, 释放所有事务处理过程中使用的锁资源. (注意:必须在最后阶段释放锁资源)

情况 1. 当协调者节点从所有参与者节点获得的响应消息都为 "同意" 时, 提交过程如下图所示:

1. 协调者节点向所有参与者节点发出 "正式提交 (commit)" 的请求.
2. 参与者节点正式完成
如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：操作, 并释放在整个事务期间内占用的资源.
3. 参与者节点向协调者节点发送 "完成" 消息.
4. 协调者节点受到所有参与者节点反馈的 "完成" 消息后, 完成事务.

情况 2. 如果任一参与者节点在第一阶段返回的响应消息为 "中止", 或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时:

1. 协调者节点向所有参与者节点发出 "回滚操作 (rollback)" 的请求.
2. 参与者节点利用之前写入的 undo 信息执行回滚, 并释放在整个事务期间内占用的资源.
3. 参与者节点向协调者节点发送 "回滚完成" 消息.
4. 协调者节点受到所有参与者节点反馈的 "回滚完成" 消息后, 取消事务.


Limits
------------------------------------------------------------------------------
二阶段提交看起来确实能够提供原子性的操作, 但是不幸的事, 二阶段提交还是有几个缺点的:

1. 同步阻塞问题

    执行过程中, 所有参与节点都是事务阻塞型的. 当参与者占有公共资源时, 其他第三方节点访问公共资源不得不处于阻塞状态. 也就是说从投票阶段到提交阶段完成这段时间, 资源是被锁住的.

2. 单点故障. 由于协调者的重要性, 一旦协调者发生故障. 参与者会一直阻塞下去.

    尤其在第二阶段, 协调者发生故障, 那么所有的参与者还都处于锁定事务资源的状态中, 而无法继续完成事务操作.

    协调者发出 Commit 消息之前宕机的情况:

    果是协调者挂掉, 可以重新选举一个协调者, 但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题

3. 数据不一致. 在二阶段提交的 Commit Phase 中, 当协调者向参与者发送 commit 请求之后, 发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障, 这回导致只有一部分参与者接受到了 commit 请求. 而在这部分参与者接到 commit 请求之后就会执行 commit 操作. 但是其他部分未接到 commit 请求的机器则无法执行事务提交. 于是整个分布式系统便出现了数据不一致性的现象.

4. 二阶段无法解决的问题: 极限情况下, 对某一事务的不确定性!

    协调者发出 Commit 消息之后宕机的情况

    协调者再发出 commit 消息之后宕机, 而唯一接收到这条消息的参与者同时也宕机了. 那么即使协调者通过选举协议产生了新的协调者, 这条事务的状态也是不确定的, 没人知道事务是否被已经提交.

由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。
